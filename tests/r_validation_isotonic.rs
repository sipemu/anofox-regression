//! R Validation Tests for Isotonic Regression.
//!
//! These tests compare anofox-regression Isotonic Regression implementation against R's isoreg() function.
//! Data generated by tests/r_scripts/generate_isotonic_validation.R
//!
//! Reference: R base isoreg() function
//! PAVA (Pool Adjacent Violators Algorithm) is deterministic, so tight tolerances are expected.

use anofox_regression::solvers::{FittedRegressor, IsotonicRegressor, Regressor};
use approx::assert_relative_eq;
use faer::Col;

// =============================================================================
// Test 1: Simple Monotonic Increasing
// =============================================================================
// R Code: isoreg(x, y)

const N_ISO1: usize = 20;

#[rustfmt::skip]
const X_ISO1: [f64; 20] = [
    1.0000000000, 2.0000000000, 3.0000000000, 4.0000000000, 5.0000000000, 6.0000000000, 7.0000000000, 8.0000000000, 9.0000000000, 10.0000000000, 11.0000000000, 12.0000000000, 13.0000000000, 14.0000000000, 15.0000000000, 16.0000000000, 17.0000000000, 18.0000000000, 19.0000000000, 20.0000000000
];

#[rustfmt::skip]
const Y_ISO1: [f64; 20] = [
    4.5564376707, 2.1529527429, 4.0446926170, 4.9492939074, 5.1064024847, 4.8408132259, 7.7672829962, 5.8580114424, 9.5276355708, 6.9059288514, 9.4573044813, 11.4299680891, 6.4167089483, 8.5818168498, 9.3000179954, 10.9539255971, 10.0736206179, 7.0153168686, 7.8392996071, 13.9801700186
];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO1: [f64; 20] = [
    3.3546952068, 3.3546952068, 4.0446926170, 4.9492939074, 4.9736078553, 4.9736078553, 6.8126472193, 6.8126472193, 8.2167822111, 8.2167822111, 8.9714495921, 8.9714495921, 8.9714495921, 8.9714495921, 9.0364361372, 9.0364361372, 9.0364361372, 9.0364361372, 9.0364361372, 13.9801700186
];

#[test]
fn test_r_validation_isotonic_simple_increasing() {
    let x = Col::from_fn(N_ISO1, |i| X_ISO1[i]);
    let y = Col::from_fn(N_ISO1, |i| Y_ISO1[i]);

    let fitted = IsotonicRegressor::builder()
        .increasing(true)
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // PAVA is deterministic - use tight tolerance
    for i in 0..N_ISO1 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO1[i], epsilon = 1e-6);
    }

    // Verify monotonicity
    for i in 1..N_ISO1 {
        assert!(
            fitted_values[i] >= fitted_values[i - 1] - 1e-10,
            "Monotonicity violated at index {}",
            i
        );
    }
}

// =============================================================================
// Test 2: Monotonic Decreasing
// =============================================================================
// R Code: -isoreg(x, -y)$yf for decreasing

const N_ISO2: usize = 25;

#[rustfmt::skip]
const X_ISO2: [f64; 25] = [
    1.0000000000, 2.0000000000, 3.0000000000, 4.0000000000, 5.0000000000, 6.0000000000, 7.0000000000, 8.0000000000, 9.0000000000, 10.0000000000, 11.0000000000, 12.0000000000, 13.0000000000, 14.0000000000, 15.0000000000, 16.0000000000, 17.0000000000, 18.0000000000, 19.0000000000, 20.0000000000, 21.0000000000, 22.0000000000, 23.0000000000, 24.0000000000, 25.0000000000
];

#[rustfmt::skip]
const Y_ISO2: [f64; 25] = [
    19.0933614059, 17.0186915660, 18.0280826442, 18.8146746992, 18.8951934613, 15.9695308684, 15.5427306172, 13.4368369148, 15.0600973548, 13.3600051240, 13.8554501232, 13.5048373372, 13.2351035220, 10.9910736246, 11.5049551233, 8.6829913209, 9.0155409916, 8.3490924058, 6.1857923501, 8.0361226069, 7.6059986002, 6.4389427015, 6.9581632357, 4.8732951729, 3.6317189556
];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO2: [f64; 25] = [
    19.0933614059, 18.1891605927, 18.1891605927, 18.1891605927, 18.1891605927, 15.9695308684, 15.5427306172, 14.2484671348, 14.2484671348, 13.6077276236, 13.6077276236, 13.5048373372, 13.2351035220, 11.2480143739, 11.2480143739, 8.8492661563, 8.8492661563, 8.3490924058, 7.2759711857, 7.2759711857, 7.2759711857, 6.6985529686, 6.6985529686, 4.8732951729, 3.6317189556
];

#[test]
fn test_r_validation_isotonic_decreasing() {
    let x = Col::from_fn(N_ISO2, |i| X_ISO2[i]);
    let y = Col::from_fn(N_ISO2, |i| Y_ISO2[i]);

    let fitted = IsotonicRegressor::builder()
        .increasing(false)
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // PAVA is deterministic - use tight tolerance
    for i in 0..N_ISO2 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO2[i], epsilon = 1e-6);
    }

    // Verify monotonicity (decreasing)
    for i in 1..N_ISO2 {
        assert!(
            fitted_values[i] <= fitted_values[i - 1] + 1e-10,
            "Monotonicity violated at index {}",
            i
        );
    }
}

// =============================================================================
// Test 4: Already Monotonic Data (no pooling needed)
// =============================================================================
// R Code: isoreg(x, y) - already monotonic

const N_ISO4: usize = 10;

#[rustfmt::skip]
const X_ISO4: [f64; 10] = [
    1.0000000000, 2.0000000000, 3.0000000000, 4.0000000000, 5.0000000000, 6.0000000000, 7.0000000000, 8.0000000000, 9.0000000000, 10.0000000000
];

#[rustfmt::skip]
const Y_ISO4: [f64; 10] = [
    1.0000000000, 2.5000000000, 3.2000000000, 4.8000000000, 5.1000000000, 6.3000000000, 7.0000000000, 8.2000000000, 9.5000000000, 10.1000000000
];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO4: [f64; 10] = [
    1.0000000000, 2.5000000000, 3.2000000000, 4.8000000000, 5.1000000000, 6.3000000000, 7.0000000000, 8.2000000000, 9.5000000000, 10.1000000000
];

#[test]
fn test_r_validation_isotonic_already_monotonic() {
    let x = Col::from_fn(N_ISO4, |i| X_ISO4[i]);
    let y = Col::from_fn(N_ISO4, |i| Y_ISO4[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // Already monotonic data should pass through unchanged
    for i in 0..N_ISO4 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO4[i], epsilon = 1e-10);
    }
}

// =============================================================================
// Test 5: Ties in X values
// =============================================================================
// R Code: isoreg(x, y) with ties

const N_ISO5: usize = 12;

#[rustfmt::skip]
const X_ISO5: [f64; 12] = [
    1.0000000000, 1.0000000000, 2.0000000000, 2.0000000000, 3.0000000000, 3.0000000000, 4.0000000000, 4.0000000000, 5.0000000000, 5.0000000000, 6.0000000000, 6.0000000000
];

#[rustfmt::skip]
const Y_ISO5: [f64; 12] = [
    1.5000000000, 2.0000000000, 2.8000000000, 3.2000000000, 3.5000000000, 4.0000000000, 4.2000000000, 4.8000000000, 5.5000000000, 5.0000000000, 6.2000000000, 6.8000000000
];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO5: [f64; 12] = [
    1.7500000000, 1.7500000000, 3.0000000000, 3.0000000000, 3.7500000000, 3.7500000000, 4.5000000000, 4.5000000000, 5.2500000000, 5.2500000000, 6.5000000000, 6.5000000000
];

#[test]
fn test_r_validation_isotonic_ties() {
    let x = Col::from_fn(N_ISO5, |i| X_ISO5[i]);
    let y = Col::from_fn(N_ISO5, |i| Y_ISO5[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // Ties are averaged, then PAVA applied
    for i in 0..N_ISO5 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO5[i], epsilon = 1e-6);
    }
}

// =============================================================================
// Test 6: Large Dataset
// =============================================================================
// R Code: isoreg(x, y) large dataset

const N_ISO6: usize = 100;

#[rustfmt::skip]
const X_ISO6: [f64; 100] = [
    1.0000000000, 2.0000000000, 3.0000000000, 4.0000000000, 5.0000000000, 6.0000000000, 7.0000000000, 8.0000000000, 9.0000000000, 10.0000000000, 11.0000000000, 12.0000000000, 13.0000000000, 14.0000000000, 15.0000000000, 16.0000000000, 17.0000000000, 18.0000000000, 19.0000000000, 20.0000000000, 21.0000000000, 22.0000000000, 23.0000000000, 24.0000000000, 25.0000000000, 26.0000000000, 27.0000000000, 28.0000000000, 29.0000000000, 30.0000000000, 31.0000000000, 32.0000000000, 33.0000000000, 34.0000000000, 35.0000000000, 36.0000000000, 37.0000000000, 38.0000000000, 39.0000000000, 40.0000000000, 41.0000000000, 42.0000000000, 43.0000000000, 44.0000000000, 45.0000000000, 46.0000000000, 47.0000000000, 48.0000000000, 49.0000000000, 50.0000000000, 51.0000000000, 52.0000000000, 53.0000000000, 54.0000000000, 55.0000000000, 56.0000000000, 57.0000000000, 58.0000000000, 59.0000000000, 60.0000000000, 61.0000000000, 62.0000000000, 63.0000000000, 64.0000000000, 65.0000000000, 66.0000000000, 67.0000000000, 68.0000000000, 69.0000000000, 70.0000000000, 71.0000000000, 72.0000000000, 73.0000000000, 74.0000000000, 75.0000000000, 76.0000000000, 77.0000000000, 78.0000000000, 79.0000000000, 80.0000000000, 81.0000000000, 82.0000000000, 83.0000000000, 84.0000000000, 85.0000000000, 86.0000000000, 87.0000000000, 88.0000000000, 89.0000000000, 90.0000000000, 91.0000000000, 92.0000000000, 93.0000000000, 94.0000000000, 95.0000000000, 96.0000000000, 97.0000000000, 98.0000000000, 99.0000000000, 100.0000000000
];

#[rustfmt::skip]
const Y_ISO6: [f64; 100] = [
    3.6492270388, 3.0255509228, 7.3623043153, 5.3528306961, 7.6916757576, 7.8313571262, 6.7614955219, 10.8488726539, 9.9643489586, 9.6214739504, 10.3647004920, 11.4112380695, 10.9514031563, 6.7353370356, 12.0462744689, 11.4491480359, 12.6471627242, 13.6006576524, 15.1763020716, 12.3254697758, 15.7015410329, 14.5750194591, 15.9452537180, 16.0780313091, 16.0813172443, 13.7323801329, 15.4531776882, 16.8097851094, 14.7252093847, 15.6174335033, 17.5747878350, 18.1228308552, 17.9293393224, 16.1641912384, 16.0985680013, 20.2690605147, 18.6351697472, 18.6259023526, 18.5536491889, 17.1821726183, 20.1273680594, 19.1165123266, 19.3981805134, 21.2997682350, 21.3572714633, 22.4351645133, 19.8527029166, 21.7601325319, 23.0866656846, 19.5470201164, 20.1330964053, 19.9356996315, 19.6515086686, 22.1653815149, 23.2284019708, 24.2513923840, 24.2166299366, 21.3425063473, 25.8161600961, 22.2377399641, 23.5890197464, 22.9886397992, 23.6282365416, 24.2822895518, 24.3655146819, 24.3344763876, 24.7181674075, 24.0104808999, 24.1635458927, 22.6081521762, 24.7049487292, 24.6868687359, 29.6848477365, 23.7638014543, 26.1866464414, 23.9129560603, 24.1192395500, 26.6823361783, 25.1696245496, 26.8300818085, 26.3576116779, 26.2456480047, 24.2942839693, 25.6583322442, 27.9279080336, 28.6722863781, 27.2428211289, 28.1425888850, 29.9862778612, 30.6202825560, 26.9725053899, 28.5990097995, 30.7331998844, 28.3814847736, 29.1616788070, 29.2647159660, 28.2150548785, 29.0314588025, 29.8054557946, 29.3791967264
];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO6: [f64; 100] = [
    3.3373889808, 3.3373889808, 6.3575675057, 6.3575675057, 7.4281761352, 7.4281761352, 7.4281761352, 9.9853391880, 9.9853391880, 9.9853391880, 9.9853391880, 9.9853391880, 9.9853391880, 9.9853391880, 11.7477112524, 11.7477112524, 12.6471627242, 13.6006576524, 13.7508859237, 13.7508859237, 15.1382802460, 15.1382802460, 15.4580320185, 15.4580320185, 15.4580320185, 15.4580320185, 15.4580320185, 15.7174759991, 15.7174759991, 15.7174759991, 17.1779434505, 17.1779434505, 17.1779434505, 17.1779434505, 17.1779434505, 18.6531908843, 18.6531908843, 18.6531908843, 18.6531908843, 18.6531908843, 19.5473536331, 19.5473536331, 19.5473536331, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 20.9059030166, 22.1653815149, 23.2284019708, 23.2701762226, 23.2701762226, 23.2701762226, 23.6519592295, 23.6519592295, 23.6519592295, 23.6519592295, 23.6519592295, 24.0689467139, 24.0689467139, 24.0689467139, 24.0689467139, 24.0689467139, 24.0689467139, 24.0689467139, 24.6959087326, 24.6959087326, 25.5334982485, 25.5334982485, 25.5334982485, 25.5334982485, 25.5334982485, 25.8911312046, 25.8911312046, 25.8911312046, 25.8911312046, 25.8911312046, 25.8911312046, 25.8911312046, 27.9279080336, 27.9575537535, 27.9575537535, 28.1425888850, 29.0445189017, 29.0445189017, 29.0445189017, 29.0445189017, 29.1312655187, 29.1312655187, 29.1312655187, 29.1312655187, 29.1312655187, 29.1312655187, 29.5923262605, 29.5923262605
];

#[test]
fn test_r_validation_isotonic_large_dataset() {
    let x = Col::from_fn(N_ISO6, |i| X_ISO6[i]);
    let y = Col::from_fn(N_ISO6, |i| Y_ISO6[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // PAVA is deterministic
    for i in 0..N_ISO6 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO6[i], epsilon = 1e-6);
    }

    // Verify monotonicity
    for i in 1..N_ISO6 {
        assert!(
            fitted_values[i] >= fitted_values[i - 1] - 1e-10,
            "Monotonicity violated at index {}",
            i
        );
    }
}

// =============================================================================
// Test 7: Step Function Pattern
// =============================================================================
// R Code: isoreg(x, y) step function

const N_ISO7: usize = 30;

#[rustfmt::skip]
const X_ISO7: [f64; 30] = [
    1.0000000000, 2.0000000000, 3.0000000000, 4.0000000000, 5.0000000000, 6.0000000000, 7.0000000000, 8.0000000000, 9.0000000000, 10.0000000000, 11.0000000000, 12.0000000000, 13.0000000000, 14.0000000000, 15.0000000000, 16.0000000000, 17.0000000000, 18.0000000000, 19.0000000000, 20.0000000000, 21.0000000000, 22.0000000000, 23.0000000000, 24.0000000000, 25.0000000000, 26.0000000000, 27.0000000000, 28.0000000000, 29.0000000000, 30.0000000000
];

#[rustfmt::skip]
const Y_ISO7: [f64; 30] = [
    2.3340158070, 1.8557021475, 1.8700492902, 2.2090587730, 1.6830894760, 4.9877904575, 4.5345365533, 5.3501508648, 4.9179062896, 4.8596464026, 4.6285243016, 4.9976713899, 4.7599153466, 4.8399523010, 5.3863025737, 7.9473422389, 7.6784652848, 8.0489620647, 7.8911784753, 8.1770040644, 8.4297265783, 7.7021922467, 8.1363950893, 8.0254694176, 8.2686696747, 11.9310665583, 12.2509857205, 11.4764832416, 12.5068376764, 12.2594333936
];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO7: [f64; 30] = [
    1.9903830987, 1.9903830987, 1.9903830987, 1.9903830987, 1.9903830987, 4.7611635054, 4.7611635054, 4.9076809852, 4.9076809852, 4.9076809852, 4.9076809852, 4.9076809852, 4.9076809852, 4.9076809852, 5.3863025737, 7.8129037618, 7.8129037618, 7.9700702700, 7.9700702700, 8.0941574793, 8.0941574793, 8.0941574793, 8.0941574793, 8.0941574793, 8.2686696747, 11.8861785068, 11.8861785068, 11.8861785068, 12.3831355350, 12.3831355350
];

#[test]
fn test_r_validation_isotonic_step_function() {
    let x = Col::from_fn(N_ISO7, |i| X_ISO7[i]);
    let y = Col::from_fn(N_ISO7, |i| Y_ISO7[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // PAVA is deterministic
    for i in 0..N_ISO7 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO7[i], epsilon = 1e-6);
    }
}

// =============================================================================
// Test 8: Edge Case - Two Observations
// =============================================================================
// R Code: isoreg(x, y) two observations

const N_ISO8: usize = 2;

#[rustfmt::skip]
const X_ISO8: [f64; 2] = [1.0000000000, 2.0000000000];

#[rustfmt::skip]
const Y_ISO8: [f64; 2] = [5.0000000000, 3.0000000000];

#[rustfmt::skip]
const EXPECTED_FITTED_ISO8: [f64; 2] = [4.0000000000, 4.0000000000];

#[test]
fn test_r_validation_isotonic_two_observations() {
    let x = Col::from_fn(N_ISO8, |i| X_ISO8[i]);
    let y = Col::from_fn(N_ISO8, |i| Y_ISO8[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    // Two observations that violate monotonicity should be pooled
    for i in 0..N_ISO8 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO8[i], epsilon = 1e-10);
    }
}

// =============================================================================
// Additional Tests
// =============================================================================

#[test]
fn test_isotonic_r_squared() {
    let x = Col::from_fn(N_ISO1, |i| X_ISO1[i]);
    let y = Col::from_fn(N_ISO1, |i| Y_ISO1[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    // R² should be between 0 and 1
    let r2 = fitted.r_squared();
    assert!(r2 >= 0.0);
    assert!(r2 <= 1.0);

    // For data with clear increasing trend, R² should be reasonable
    assert!(r2 > 0.5);
}

#[test]
fn test_isotonic_prediction() {
    let x = Col::from_fn(N_ISO4, |i| X_ISO4[i]);
    let y = Col::from_fn(N_ISO4, |i| Y_ISO4[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit_1d(&x, &y)
        .expect("fit should succeed");

    // Predict at training points - should match fitted values
    let preds = fitted.predict_1d(&x);
    let fitted_values = fitted.fitted_values();

    for i in 0..N_ISO4 {
        assert_relative_eq!(preds[i], fitted_values[i], epsilon = 1e-10);
    }

    // Predict at intermediate points
    let x_new = Col::from_fn(5, |i| 1.5 + i as f64 * 2.0);
    let preds_new = fitted.predict_1d(&x_new);

    // Predictions should be monotonic
    for i in 1..preds_new.nrows() {
        assert!(
            preds_new[i] >= preds_new[i - 1] - 1e-10,
            "Prediction monotonicity violated at index {}",
            i
        );
    }
}

#[test]
fn test_isotonic_matrix_interface() {
    let x = Col::from_fn(N_ISO1, |i| X_ISO1[i]);
    let y = Col::from_fn(N_ISO1, |i| Y_ISO1[i]);

    // Create matrix with single column
    let x_mat = faer::Mat::from_fn(N_ISO1, 1, |i, _| x[i]);

    let fitted = IsotonicRegressor::builder()
        .build()
        .fit(&x_mat, &y)
        .expect("fit should succeed");

    let fitted_values = fitted.fitted_values();

    for i in 0..N_ISO1 {
        assert_relative_eq!(fitted_values[i], EXPECTED_FITTED_ISO1[i], epsilon = 1e-6);
    }
}
