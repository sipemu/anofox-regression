//! R Validation Tests for PLS (Partial Least Squares) Regression.
//!
//! These tests compare anofox-regression PLS implementation against R's pls package.
//! Data generated by tests/r_scripts/generate_pls_validation.R
//!
//! Reference: R pls package (version 2.8.5)
//! https://cran.r-project.org/package=pls

use anofox_regression::solvers::{FittedRegressor, PlsRegressor, Regressor};
use approx::assert_relative_eq;
use faer::{Col, Mat};

// =============================================================================
// Test 1: Simple PLS with 2 components (SIMPLS)
// =============================================================================
// R Code: plsr(y ~ X, ncomp = 2, method = "simpls", scale = FALSE)

const N_PLS1: usize = 30;
const P_PLS1: usize = 5;
const NCOMP_PLS1: usize = 2;

#[rustfmt::skip]
const X_PLS1: [f64; 150] = [
    1.3709584471, -0.5646981714, 0.3631284113, 0.6328626050, 0.4042683231, -0.1061245161, 1.5115219974, -0.0946590384, 2.0184237139, -0.0627140991, 1.3048696542, 2.2866453927, -1.3888607011, -0.2787887668, -0.1333213364, 0.6359503981, -0.2842529214, -2.6564554209, -2.4404669286, 1.3201133457, -0.3066385941, -1.7813084340, -0.1719173558, 1.2146746992, 1.8951934613, -0.4304691316, -0.2572693828, -1.7631630852, 0.4600973548, -0.6399948760, 0.9474613705, -0.8607521667, 0.6043407527, 0.3609101131, 0.1426342288, -0.4457628597, 1.0557367881, -0.3063459803, 1.2528489007, 0.3424027043, 0.8607509969, 1.2791170596, -0.9232404260, -0.3039736615, 0.0836791289, 0.8748918570, -0.4967847983, -1.7231237054, -1.6828574324, 1.1927490167, -0.2835804575, -0.9959301832, -0.6438589074, 1.3571099658, 1.5860688164, -0.3465611888, -0.6147907070, -1.0413115496, 0.4670263075, -0.4499031011, -0.3672346427, 0.1852305649, 0.5818237274, 1.3997368273, -0.7272920595, 1.3025426320, 0.3358481198, 1.0385060987, 0.9207285683, 0.7208781629, -1.0431189386, -0.0901863866, 0.6235181620, -0.9535233578, -0.5428288146, 0.5809964977, 0.7681787378, 0.4637675885, -0.8857762974, -1.0997808986, 1.5127070098, 0.2579214375, 0.0884402292, -0.1208965375, -1.1943288952, 0.6119968980, -0.2171398457, -0.1827567063, 0.9333463286, 0.8217731105, -0.2634965356, 0.0313626578, 0.5392203284, 1.1787203298, -0.6376855222, 0.7747867747, 0.4088282595, 0.9416442034, 0.5693215361, 0.2577848979, -0.7935034347, -0.1411667049, 0.5493368703, -1.0216191793, -0.6260971405, 0.6819521689, 0.6952979712, 0.4883115782, -0.3455753487, -0.8540604332, 0.8099797603, 0.2730925895, 0.3050172088, 0.3151906184, -1.2308354358, 0.2594264053, -0.3148761555, -0.3570165215, 0.6175283182, 0.6203428949, -1.4936250673, -1.4704357414, 0.1247023862, -0.9966391349, -0.0018226143, -0.4282588814, -0.6136716064, -2.0246778454, -1.2247479504, 0.1795164411, 0.5676205944, -0.4928773536, 0.0000628841, 1.1228896434, 1.4398557430, -1.0971137684, -0.1173195603, 1.2014984009, -0.4697295806, -0.0524694849, -0.0861072982, -0.8876790179, -0.4446840049, -0.0294448791, -0.4138688491, 1.1133860234, -0.4809928417, -0.4331690326, 0.6968625766, -1.0563684132
];

#[rustfmt::skip]
const Y_PLS1: [f64; 30] = [
    1.6529036584, -1.6091559665, 0.6743736819, -0.6102115941, 1.5849023824, -2.0071812463, 2.4381390044, -1.7330279744, 2.3094051486, -1.1161800588, 4.1136529331, 4.0335358699, -3.6112307550, 0.2138864639, 1.3460134172, 0.4841467748, -1.2800603895, -5.1206621687, -4.6933743826, 4.5061187481, -2.3656250013, -3.7276068996, -1.6246861690, 2.9281271382, 4.6695087379, -1.0810294540, -0.3573614861, -3.6725761987, 0.7309932828, -3.1629122713
];

const EXPECTED_INTERCEPT_PLS1: f64 = -0.0646914345;

#[rustfmt::skip]
const EXPECTED_COEFS_PLS1: [f64; 5] = [
    1.3054420914, 0.9643404528, -0.6274651737, -0.5068329022, 0.3295550480
];

const EXPECTED_R2_PLS1: f64 = 0.9764465344;

#[test]
fn test_r_validation_pls_simple() {
    // Build matrix from column-major data (R uses column-major)
    let x = Mat::from_fn(N_PLS1, P_PLS1, |i, j| X_PLS1[i + j * N_PLS1]);
    let y = Col::from_fn(N_PLS1, |i| Y_PLS1[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS1)
        .with_intercept(true)
        .scale(false)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let result = fitted.result();
    let intercept = result.intercept.expect("intercept should exist");

    // R-validated intercept (tolerance for numerical differences)
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_PLS1, epsilon = 0.5);

    // R-validated coefficients
    for (i, expected) in EXPECTED_COEFS_PLS1.iter().enumerate() {
        assert_relative_eq!(result.coefficients[i], *expected, epsilon = 0.5);
    }

    // R-validated R²
    assert_relative_eq!(result.r_squared, EXPECTED_R2_PLS1, epsilon = 0.05);

    // Verify number of components
    assert_eq!(fitted.n_components(), NCOMP_PLS1);
}

// =============================================================================
// Test 2: PLS with 4 components (SIMPLS)
// =============================================================================
// R Code: plsr(y ~ X, ncomp = 4, method = "simpls", scale = FALSE)

const N_PLS2: usize = 50;
const P_PLS2: usize = 8;
const NCOMP_PLS2: usize = 4;

#[rustfmt::skip]
const X_PLS2: [f64; 400] = [
    -0.7292172765, 0.9980689086, 1.2584816646, 1.2488636888, -1.3806370495, 2.0499606936, 1.0168728298, -0.0267174641, 0.7036077788, -0.9713852292, -1.0961562416, 0.0490504509, -1.1984958566, 0.1900189986, 1.2977058996, -1.0338737230, -0.7384407542, 0.0465639395, -1.0175961198, -0.3832839599, 0.8727554117, 0.9695450140, 0.3838466650, -1.8515556631, -0.0539967368, 1.0647732143, 0.8131950374, -0.1908164741, -2.6999298086, 0.0609666388, 0.5737516975, 0.0458035797, 0.1574125402, 0.4315653729, -0.3965497361, 1.3099782258, 0.4703933999, -1.2426702706, 1.3815754564, 1.2044589370, 0.8240739637, -1.6626294022, -0.5693063436, 0.6355138173, 0.0437220076, 0.3480123037, 2.4595935489, -0.8183803244, -2.1132001149, 0.2736952724, -0.9063620242, 0.7454617255, -0.4348402244, 2.5867145870, -0.5378970864, 0.1376527021, 0.1388003575, 0.8545481444, 0.3084228188, -1.9170323080, -0.3334676403, 0.7749573029, -0.3205578441, 0.7920778412, 0.2428391429, -0.3680494523, 0.2608372398, 1.0069128186, -1.5516743340, -0.1484727128, 0.1908644423, -0.4680571495, -0.9192053614, -1.1861986529, 0.5706086990, -0.0968906919, -0.5409292983, 0.1061713773, -2.0466931777, 1.0641637679, -0.3124699070, 0.2028698856, 0.0982300936, 0.1292289430, 1.6904171216, -0.4323344894, 1.2865884722, -0.3412278936, -0.4207331684, 0.2925740321, 0.9939938761, -0.9243075551, -0.9428741383, 0.3434182519, 1.0017134475, 0.0309453564, -0.6491484889, -1.5521900017, -1.4023553596, -0.4449995436, -0.2401922480, 0.9699187436, -0.0570725392, -0.7392206767, 0.1929148800, 0.8904451768, 1.4624089184, -1.6904960987, 0.2984014225, 1.0619463252, 0.3953269282, -0.8178376905, 0.3729797298, -0.8149211704, -0.0640857413, 0.8773721617, -0.5116775381, 0.8425153268, -0.5965065447, -1.6913475927, -0.5869890734, -0.7976563578, -0.3691365716, -0.8917779079, -0.1695569117, 0.0761847357, 2.1361605528, -1.4432432795, -1.2248032433, 0.3673715197, 1.8005677751, 0.1022629696, 1.2863744705, -1.5150859239, 1.3273916046, -0.2975667039, -0.1353130655, -1.4822198411, 0.5483419533, 2.1466767328, 2.6693855444, -1.5756177228, 0.3151492073, 1.5791758839, -0.1825402150, -0.1137711066, 0.4331001101, 0.3523186268, 0.7634693763, 0.7697283430, 0.1014228313, -0.0024492532, 0.8758931849, -0.1748778113, -0.6934476185, 1.7115016512, 0.7470749371, 0.2330010548, -0.0445253217, 0.6396173327, 1.0060657129, -0.8545566286, -0.3040618023, 0.1060726128, -0.1890439585, -1.3089007729, -0.2239650063, 0.6694810646, 1.1715634430, -2.0241379762, -0.4406128498, -0.0205667138, -1.5480030312, -1.3060001407, -0.7935507802, -0.4031377356, -1.9448760879, 0.1561736081, -1.4419018788, 1.5387811855, 0.9680814587, -1.4397884912, 0.1456191831, -0.4643013724, 0.7693162478, 0.4460638832, -0.4159056059, 0.0655959550, 0.5670807956, 0.1967200994, 2.2671128106, -1.0281747070, -0.6415788761, -1.3552827788, -0.0274101210, 0.9947599966, -1.3335097863, -0.4955792174, -1.8156104611, 1.5240458467, 1.1391303559, 0.6339235199, 1.8068825798, -0.4926587442, 0.5364606101, 0.0299766995, 0.6260193715, -0.3074112559, -0.0674607497, 0.2546995896, -1.6326680261, -0.2361993298, -0.1885413832, -0.3464617792, 0.4939712107, -0.6290429036, 1.3968117096, 0.7281577833, 2.6605865339, -0.9100627925, 1.0761925382, 2.3888943143, 0.4161340547, -1.6385418408, -1.0225215229, 0.2840173994, 1.5530828721, 0.6931555444, -2.9483472702, -0.6820641172, 0.1630690340, -1.4443924133, 0.7417534085, -2.3318658633, 0.0243248432, 0.0017713486, -0.3500460657, -0.6564485336, 0.7292674416, 0.7576642590, 0.0216184781, -2.4237392510, -1.6100212014, -1.2790036288, 0.7749800492, -0.1392112908, 1.0075546721, -1.8044416183, -1.1695480412, 0.6445605549, -0.3970913064, 0.1842846864, 0.3054830273, 1.5855689136, -1.0290880157, 1.2911146664, 1.2036614545, -1.1973331428, 0.3323411835, -0.3026372549, 0.7002938468, 0.9294900030, -0.3620050236, 0.1930152520, -0.3308417751, -0.5082864469, -1.2507410323, -0.9529867140, -1.5260919249, 0.7212225160, 1.3767984220, -0.1220813487, -1.0138233985, -0.6433980307, 2.2257046723, 2.3607451351, -1.4758418255, -0.4141515984, 0.7233015496, -0.0199541050, 1.7695387516, -0.3198443194, 0.6522096860, 0.3537108511, 3.1101045747, 1.3134460345, -1.0654210493, -0.9766822503, 0.7847079215, -1.5396629656, -1.5571877559, -1.6206114270, -0.5187215096, 1.4295562938, -0.2610809626, 0.2667844067, 0.6732711549, -0.9507511943, 0.7282372343, -1.0144046064, -0.4471987015, -0.0484074080, 0.9096731189, 1.9818936689, 0.0996234113, 1.9973613687, 1.0681588975, -0.6325997839, 0.2926261341, 1.0846635426, -1.8901126586, 0.3394857959, -0.5163390739, 0.9347895603, 1.1394783451, -0.0091087130, 1.2712788910, -1.5115246183, 0.6054387225, -1.6945172158, 0.8495428806, 0.3805058002, 1.0824156565, -0.4766543460, -1.5848988575, -1.6883912197, 0.7849320355, -0.1306215403, -1.3809973361, -0.2927784682, -0.4992895579, -0.1435993782, -0.8840813089, -1.8535398676, -0.3385647251, 1.4382693372, 2.0184475863, -0.3701948852, 0.3338027022, 1.3243199623, 0.3007932057, -0.9336872296, -1.9080891584, -1.0730414546, 0.4194251143, -1.3552502767, 1.7863354348, -1.5919446368, -0.8275305926, 0.0797726246, -0.2315949168, 0.4513679946, 0.9760556308, 0.2484466693, -0.6627266807, 0.7753156030, -0.1285800927, 1.5293971799, -1.9591642430, 0.7355890505, -0.5773298057, 0.4370355211, 0.6281045367, 0.8925738716, -0.2712100892, 1.2539073764, -1.8445081616, 0.8778655553, -0.8168816094, -2.0323502134, -1.6039872251, 0.5360425676, 2.3386883014, -0.2820906348, 1.1145857735, 1.1581013384, -0.4106567667, 0.8967160362, -0.4570274771, 0.2248892843, 1.1732387436, 0.7611930656, -0.5793510747, 0.5246932978, -1.0111328749, 1.0238118778, -0.2915871633, 0.0793375630, 0.7824716821, 0.0909501914, 0.7127348068, 0.0755674050, -0.4014918932, 1.3628966535, 1.4058193090, -0.5575875646, -0.0394911421, 0.2680244816, -1.5472722725, -0.3673152235
];

#[rustfmt::skip]
const Y_PLS2: [f64; 50] = [
    0.8698500565, 0.1953545590, 2.2371521049, -1.0910478364, -3.7059852805, 4.2039948053, -0.7266956769, 0.1378683684, 1.0727703450, 2.5114064925, -0.7584338076, -2.3237624682, -3.2996918653, 0.0456987425, 3.8527382733, -4.0733843686, -1.6923374261, -1.0169693785, 1.1188769402, -2.7428574008, -0.0141169396, 4.0527080968, 1.4836427509, -2.3230182583, -1.7846812275, 0.4504795511, 2.5430347169, -0.0061291373, -6.0593452309, 0.0090145832, 2.2678696770, -1.0461867961, -0.4521184586, -1.7456309156, -3.5696322429, 2.5728238244, -1.5185801563, -0.9356923677, 2.4363076456, 3.5782688116, 3.2958739487, -3.7649823202, 0.5007500633, -2.2288781046, 0.0138100549, 0.6293656033, 4.1836080017, 0.1625113179, -4.9089124425, 2.9134687200
];

const EXPECTED_INTERCEPT_PLS2: f64 = -0.1476068792;

#[rustfmt::skip]
const EXPECTED_COEFS_PLS2: [f64; 8] = [
    1.9780900638, -1.2134938819, -0.0587035038, 0.7949668642, 0.2201059624, -0.5128342633, -0.0011827720, 0.0657565764
];

const EXPECTED_R2_PLS2: f64 = 0.8636852841;

#[test]
fn test_r_validation_pls_four_components() {
    let x = Mat::from_fn(N_PLS2, P_PLS2, |i, j| X_PLS2[i + j * N_PLS2]);
    let y = Col::from_fn(N_PLS2, |i| Y_PLS2[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS2)
        .with_intercept(true)
        .scale(false)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let result = fitted.result();
    let intercept = result.intercept.expect("intercept should exist");

    // R-validated intercept
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_PLS2, epsilon = 0.5);

    // R-validated coefficients
    for (i, expected) in EXPECTED_COEFS_PLS2.iter().enumerate() {
        assert_relative_eq!(result.coefficients[i], *expected, epsilon = 0.5);
    }

    // R-validated R²
    assert_relative_eq!(result.r_squared, EXPECTED_R2_PLS2, epsilon = 0.1);

    // Verify number of components
    assert_eq!(fitted.n_components(), NCOMP_PLS2);
}

// =============================================================================
// Test 3: PLS with scaling (SIMPLS)
// =============================================================================
// R Code: plsr(y ~ X, ncomp = 3, method = "simpls", scale = TRUE)

const N_PLS3: usize = 40;
const P_PLS3: usize = 6;
const NCOMP_PLS3: usize = 3;

#[rustfmt::skip]
const X_PLS3: [f64; 240] = [
    -87.7664383434, -121.2897125178, 61.3286618687, -80.6203341462, -137.6456929909, -50.7847899164, -80.0935486737, -219.2785685670, -29.0937149268, 16.7174121161, 29.4692356486, 39.2741265421, -100.0843713001, -32.5727119823, -100.8348805429, -63.5431482034, -120.9840687987, -111.6463800653, 62.9881162576, -27.2521570179, -25.8841168379, 172.9558179891, -5.8392165407, -53.7063784609, 74.7286696166, -48.7257835390, 137.2907781480, -37.7672360646, -61.6152614118, -116.8125051075, 32.8640358591, 146.6510627440, -35.6009545089, 26.1467641877, 33.3328855176, 142.2193240310, 66.3876600666, -107.3655155695, -69.6901774667, -74.6130456935, 0.0014157287, -0.0000394722, 0.0036793750, -0.0065734291, -0.0037634667, 0.0074136006, -0.0009960676, -0.0065428988, 0.0097116437, 0.0001349631, -0.0091653467, 0.0170968856, -0.0116810099, -0.0178103626, -0.0225313245, 0.0065112597, -0.0053283263, -0.0027555936, 0.0028962697, -0.0046648406, -0.0160806017, -0.0194978380, -0.0034069992, 0.0017472553, -0.0227777756, 0.0029052448, 0.0042230636, 0.0129473736, 0.0016471402, 0.0020495384, 0.0060460363, -0.0001914077, -0.0007971435, 0.0011598446, 0.0074417336, -0.0043129060, -0.0049952895, -0.0086516208, -0.0095775728, 0.0032679997, 1547.3722256852, -968.8595688644, -188.4404262595, -1030.0011614559, 908.0864418605, -317.3818647081, 179.0039665404, 348.0281877292, -1054.2790212744, -104.7442881107, -228.3426170945, 675.3555624275, -1233.2446935063, -1199.9615444228, 765.8665766161, -588.0978612830, -660.2958299756, 113.0135221973, -320.3987996860, 1866.3814969388, 259.5314557678, 161.5600709181, 931.0749093354, -59.9467492596, 48.7397000775, -1072.8754007340, -2292.9714304807, -1207.2068500643, 114.1094297972, -1033.2970791054, 688.8077523421, 725.0830176749, 217.3802109391, -201.6567316184, -1365.6898605887, -308.9376086772, -452.9028865372, 663.2291445198, 1308.6295367487, 501.0403098945, -1.1282885352, 1.6709973054, 1.0103530325, 0.2235212159, -2.2064845932, -0.9545856186, -0.0685730672, 0.7613059016, -1.1799042000, 3.2111989568, -2.5538248510, -0.2359339493, -0.2595626433, -0.6633669166, -0.3189907108, 0.7423951576, -0.8742926758, -2.0828137663, 0.0937679028, -0.0018198120, -0.0131006524, 0.6679680746, -0.0131677030, 0.7760470305, -2.0107353326, -1.1281804950, 0.3487995716, -0.3528984821, 0.9447745979, -1.0047198525, 0.7239027325, -0.6688327410, -1.1130401937, -0.3428051894, 0.0497793232, -1.2276819615, -0.7640059108, -1.2461820616, 1.0167739778, 0.7236126241, -1.0325271371, 0.5573460041, -0.2555814231, -1.1133917571, 0.4211974396, -0.3229503118, 0.8801799012, -0.1948636068, 1.1880549821, -0.5097645118, 0.2195480109, 0.3702944214, 0.2791083937, 0.2019424373, -0.0129965424, -0.0908650061, 1.3650313653, 0.9081305689, -0.6098881714, 1.3964372212, 0.1447983733, -0.6406067716, 0.1698022596, -0.1571874874, 0.1009395945, -0.9733941541, -0.8198252753, 1.3629189690, 0.9613709305, -0.8837244744, -0.9000921154, 1.7233331328, 1.9090421621, -0.7771411959, -1.3023052626, 2.6234951668, 0.2296289143, 0.1867498921, 0.0761366350, 1.4048601863, -0.1917222353, 1.4593921642, -0.2206554511, 0.5051458863, -1.0334970061, 0.1704734715, 1.2006681609, -0.1634059148, 1.2824758631, 2.7271963879, 0.9419242173, -0.2486140373, 0.0964788597, -0.4339309413, 2.1786678675, -2.9587796191, 0.0808882392, 0.1101378046, 0.2134483263, -1.5578196126, 0.2162115463, 0.1876638170, 1.2586221252, 0.5235177809, 1.1154542775, -0.9575022422, -0.1244055799, 0.1917378290, 0.2722172506, -0.6938144637, 1.4791719209, -0.6117670216, -1.6143099744, 0.4024901106, 0.6645554473, 0.9441270710, -0.9462607977, -0.2482884492, -1.3284364685, 0.8447637421
];

#[rustfmt::skip]
const Y_PLS3: [f64; 40] = [
    -0.1113182775, 0.2610396959, 3.5105977771, -3.2544144170, -4.4008170261, -5.5211848928, -0.6152404393, -1.6171738854, -4.2912343164, 0.2485431616, -5.5239019920, -0.4062194131, -1.7071880056, -3.6294874617, -4.5118785099, -0.5218058279, -9.2452341042, -5.2555803811, 3.7726373534, -0.7626344547, 1.5280593407, 7.2810028810, -1.4122120307, -2.3395906963, -3.1510554733, -1.7734068565, 3.0555457006, 0.1262544405, 2.1088606094, -1.8866076069, 5.1456926964, 2.2612538609, -4.8626274373, -0.9065387394, 1.3885471317, 3.4306848250, 2.8743468787, -7.1830391494, -1.6518739650, 2.2850560679
];

const EXPECTED_R2_PLS3: f64 = 0.6326666025;

#[test]
fn test_r_validation_pls_with_scaling() {
    let x = Mat::from_fn(N_PLS3, P_PLS3, |i, j| X_PLS3[i + j * N_PLS3]);
    let y = Col::from_fn(N_PLS3, |i| Y_PLS3[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS3)
        .with_intercept(true)
        .scale(true)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let result = fitted.result();

    // R-validated R² (main validation for scaled PLS)
    // Scaling can produce different coefficient values but should produce similar fit quality
    assert_relative_eq!(result.r_squared, EXPECTED_R2_PLS3, epsilon = 0.15);

    // Verify predictions are reasonable
    let preds = fitted.predict(&x);
    let y_mean: f64 = y.iter().sum::<f64>() / N_PLS3 as f64;
    let tss: f64 = y.iter().map(|&yi| (yi - y_mean).powi(2)).sum();
    let rss: f64 = (0..N_PLS3).map(|i| (y[i] - preds[i]).powi(2)).sum();
    let r2_computed = 1.0 - rss / tss;

    // Verify R² is consistent
    assert_relative_eq!(result.r_squared, r2_computed, epsilon = 0.001);

    // Verify number of components
    assert_eq!(fitted.n_components(), NCOMP_PLS3);
}

// =============================================================================
// Test 4: Small dataset with 1 component (SIMPLS)
// =============================================================================
// R Code: plsr(y ~ X, ncomp = 1, method = "simpls", scale = FALSE)

const N_PLS4: usize = 15;
const P_PLS4: usize = 3;
const NCOMP_PLS4: usize = 1;

#[rustfmt::skip]
const X_PLS4: [f64; 45] = [
    -1.0641097150, -1.6135774725, 0.5998110887, 1.7329647054, 1.9345045625, 0.5328205757, 0.7196657560, 0.5600933858, -0.0180869317, -3.3717390826, 0.7607032448, -0.3912268522, 1.0099012238, -0.6269731471, -1.6345773695, 1.2452426520, 0.1813774466, 3.4953042640, 0.9155919133, 1.0485065174, 0.7638249369, -0.6033873769, -0.3704296627, 1.0598259383, 1.0551105298, 0.5829721611, -0.9865674355, 1.6846218117, -1.3668410457, -0.4332143486, 2.3250584937, 0.5241221812, 0.9707334164, 0.3769733972, -0.9959333965, -0.5974829130, 0.1652514231, -2.9284771786, -0.8479142266, 0.7985845122, -0.2984559880, -0.2836113769, 0.8695193066, -0.5443552847, 0.6288032354
];

#[rustfmt::skip]
const Y_PLS4: [f64; 15] = [
    -0.1471478685, -3.1519701978, 4.6780614949, 4.5953275674, 4.3577112449, 1.9632861238, 0.9060352157, -0.3083551372, 1.1832625445, -5.4363568493, 2.0716823791, -2.1642948063, 4.3605810231, -3.2168930816, -3.6959096328
];

const EXPECTED_INTERCEPT_PLS4: f64 = -0.1044960814;

#[rustfmt::skip]
const EXPECTED_COEFS_PLS4: [f64; 3] = [
    1.9406013572, 1.1198179218, -0.0774983939
];

const EXPECTED_R2_PLS4: f64 = 0.9799365395;

#[test]
fn test_r_validation_pls_single_component() {
    let x = Mat::from_fn(N_PLS4, P_PLS4, |i, j| X_PLS4[i + j * N_PLS4]);
    let y = Col::from_fn(N_PLS4, |i| Y_PLS4[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS4)
        .with_intercept(true)
        .scale(false)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    let result = fitted.result();
    let intercept = result.intercept.expect("intercept should exist");

    // R-validated intercept
    assert_relative_eq!(intercept, EXPECTED_INTERCEPT_PLS4, epsilon = 0.5);

    // R-validated coefficients
    for (i, expected) in EXPECTED_COEFS_PLS4.iter().enumerate() {
        assert_relative_eq!(result.coefficients[i], *expected, epsilon = 0.5);
    }

    // R-validated R²
    assert_relative_eq!(result.r_squared, EXPECTED_R2_PLS4, epsilon = 0.05);

    // Verify number of components
    assert_eq!(fitted.n_components(), NCOMP_PLS4);
}

// =============================================================================
// Additional Tests
// =============================================================================

#[test]
fn test_pls_transform_produces_scores() {
    let x = Mat::from_fn(N_PLS1, P_PLS1, |i, j| X_PLS1[i + j * N_PLS1]);
    let y = Col::from_fn(N_PLS1, |i| Y_PLS1[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS1)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    // Get scores from training data
    let training_scores = fitted.scores();
    assert_eq!(training_scores.nrows(), N_PLS1);
    assert_eq!(training_scores.ncols(), NCOMP_PLS1);

    // Transform should produce similar scores on training data
    let transformed_scores = fitted.transform(&x);
    assert_eq!(transformed_scores.nrows(), N_PLS1);
    assert_eq!(transformed_scores.ncols(), NCOMP_PLS1);

    // Scores should be similar (not exactly equal due to normalization differences)
    for i in 0..N_PLS1 {
        for k in 0..NCOMP_PLS1 {
            // Allow for sign flips and scaling differences
            let ratio = if training_scores[(i, k)].abs() > 1e-10 {
                transformed_scores[(i, k)] / training_scores[(i, k)]
            } else {
                1.0
            };
            // All ratios should be similar (same sign flip and scale)
            assert!(
                ratio.abs() > 0.01 || training_scores[(i, k)].abs() < 1e-10,
                "Score mismatch at ({}, {})",
                i,
                k
            );
        }
    }
}

#[test]
fn test_pls_prediction_consistency() {
    let x = Mat::from_fn(N_PLS2, P_PLS2, |i, j| X_PLS2[i + j * N_PLS2]);
    let y = Col::from_fn(N_PLS2, |i| Y_PLS2[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS2)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    // Predictions should equal fitted values on training data
    let predictions = fitted.predict(&x);
    let fitted_values = &fitted.result().fitted_values;

    for i in 0..N_PLS2 {
        assert_relative_eq!(predictions[i], fitted_values[i], epsilon = 1e-10);
    }
}

#[test]
fn test_pls_weights_loadings_dimensions() {
    let x = Mat::from_fn(N_PLS2, P_PLS2, |i, j| X_PLS2[i + j * N_PLS2]);
    let y = Col::from_fn(N_PLS2, |i| Y_PLS2[i]);

    let fitted = PlsRegressor::builder()
        .n_components(NCOMP_PLS2)
        .build()
        .fit(&x, &y)
        .expect("fit should succeed");

    // Check dimensions
    assert_eq!(fitted.weights().nrows(), P_PLS2);
    assert_eq!(fitted.weights().ncols(), NCOMP_PLS2);
    assert_eq!(fitted.x_loadings().nrows(), P_PLS2);
    assert_eq!(fitted.x_loadings().ncols(), NCOMP_PLS2);
    assert_eq!(fitted.y_loadings().nrows(), NCOMP_PLS2);
    assert_eq!(fitted.scores().nrows(), N_PLS2);
    assert_eq!(fitted.scores().ncols(), NCOMP_PLS2);
}
